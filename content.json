{"pages":[],"posts":[{"title":"ControllerAdvice失效","text":"jar包和本地冲突 接手了一个项目, 整个项目没有使用过自定义异常, 自己加入了全局异常无效 自己加入的全局异常如下: 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.freemud.delivery.aop;import com.freemud.delivery.entity.enums.ResultCodeEnum;import com.freemud.delivery.entity.exception.DeliveryException;import com.freemud.delivery.entity.util.ExceptionUtils;import com.freemud.delivery.entity.vo.ApiResult;import lombok.extern.slf4j.Slf4j;import org.springframework.validation.ObjectError;import org.springframework.web.bind.MethodArgumentNotValidException;import org.springframework.web.bind.annotation.ExceptionHandler;import org.springframework.web.bind.annotation.RestControllerAdvice;import java.util.List;import java.util.stream.Collectors;@RestControllerAdvice@Slf4jpublic class GlobalExceptionHandler { @ExceptionHandler({MethodArgumentNotValidException.class}) public ApiResult handler(MethodArgumentNotValidException e) { List&lt;String&gt; errorList = e.getBindingResult().getAllErrors() .stream() .map(ObjectError::getDefaultMessage) .map(String::valueOf) .collect(Collectors.toList()); return new ApiResult(ResultCodeEnum.PARAM_ERROR, errorList); } @ExceptionHandler({DeliveryException.class}) public ApiResult handler(DeliveryException e) { return new ApiResult(e.getCode(), e.getMessage(), null); } @ExceptionHandler({Exception.class}) public ApiResult handler(Exception e) { log.error(ExceptionUtils.getFullStackTrace(e)); return new ApiResult(ResultCodeEnum.SYSTEM_ERROR); }} 使用时发现并没有生效,当我故意入参错误时,报错如下: 122020-11-06 17:51:51,113 WARN deliverycenter (AbstractHandlerExceptionResolver.java:140) Resolved [org.springframework.web.bind.MethodArgumentNotValidException: Validation failed for argument at index 0 in method: public com.freemud.delivery.entity.vo.ApiResult&lt;com.freemud.delivery.entity.vo.PageResult&lt;com.freemud.delivery.entity.vo.service.delivery.DeliveryVO&gt;&gt; com.freemud.delivery.service.controller.QueryDeliveryController.queryListByDeliveryStatus(com.freemud.delivery.entity.vo.service.delivery.QueryDeliveryListReqVO), with 1 error(s): [Field error in object 'queryDeliveryListReqVO' on field 'partnerId': rejected value []; codes [NotBlank.queryDeliveryListReqVO.partnerId,NotBlank.partnerId,NotBlank.java.lang.String,NotBlank]; arguments [org.springframework.context.support.DefaultMessageSourceResolvable: codes [queryDeliveryListReqVO.partnerId,partnerId]; arguments []; default message [partnerId]]; default message [partnerId不能为空]] ] 我在console中搜索我的这个bean时发现这个提示: 122020-11-06 17:55:52,459 INFO deliverycenter (ExceptionHandlerExceptionResolver.java:288) Detected @ExceptionHandler methods in platformExceptionHandler2020-11-06 17:55:52,459 INFO deliverycenter (ExceptionHandlerExceptionResolver.java:288) Detected @ExceptionHandler methods in globalExceptionHandler 原来这个服务引入了公司的一个基础包; 这个包里已经有了全局异常; 这个类如下: 123456789101112131415161718192021222324252627282930//// Source code recreated from a .class file by IntelliJ IDEA// (powered by Fernflower decompiler)//package com.freemud.framework.exception;import com.freemud.framework.constants.SysStatusCode;import com.freemud.framework.result.ApiResult;import com.freemud.framework.util.Utils;import org.springframework.web.bind.annotation.ControllerAdvice;import org.springframework.web.bind.annotation.ExceptionHandler;import org.springframework.web.bind.annotation.ResponseBody;@ControllerAdvice@ResponseBodypublic class PlatformExceptionHandler { public PlatformExceptionHandler() { } @ExceptionHandler({Exception.class}) public ApiResult handleException() { return new ApiResult(SysStatusCode.SYSTEM_ERROR); } @ExceptionHandler({PlatformException.class}) public ApiResult handlePlatformException(PlatformException platformException) { return Utils.notNull(platformException.getCode()) ? new ApiResult(platformException.getCode(), platformException.getMsg()) : new ApiResult(SysStatusCode.SYSTEM_ERROR); }} 我认为这个全局异常处理太差劲了; 完全没办法满足我( 同时我有点不理解了,原来是有自定义异常类的; 但是整个项目从来没有见到过一个使用的地方) 所以我现在需要做的事情就是让基础jar包的失效,使用我自己的全局异常处理 这时候在SpringBoot启动类中的排除这一个bean的注入,代码如下: 12345@ComponentScan(value = &quot;com.free.*&quot;, excludeFilters = @ComponentScan.Filter( type = FilterType.ASSIGNABLE_TYPE, classes = {PlatformExceptionHandler.class} )) 重启服务,调试成功","link":"/2020/11/06/ControllerAdvice%E5%A4%B1%E6%95%88/"},{"title":"hexo","text":"hexo学习 参考博客如下: hexo从零开始到搭建完整 hexo史上最全搭建教程 技术小白搭建个人博客 github+hexo 写博客常用命令 hexo Docs 博客本地启动: hexo s = hexo server 本地创建一个新的页面: hexo new [title] 写完之后生成静态文件: hexo g = hexo generate 提交到远程git上: hexo d = hero deploy","link":"/2020/09/25/first/"},{"title":"git网站","text":"git学习网站 网址 网站描述 https://git-scm.com/book/zh/v2 git 官网教程 https://www.zhihu.com/question/29929269 知乎的一篇推荐 https://learngitbranching.js.org git learning 图文教程 https://github.com/k88hudson/git-flight-rules/blob/master/README_zh-CN.md git flight rules https://www.jianshu.com/p/964de879904a commit 合并 https://segmentfault.com/a/1190000009048911 git commit 提交规范","link":"/2020/10/15/git/"},{"title":"log打印时增加链路id","text":"为mq服务生成一个trackingNo 前提 在使用分布式项目中,一个用户的一次请求应该是一条链路,当需要查找日志时, 可以根据一个id来将用户在所有子模块中的流程都获取到, 这时候在两个服务之间需要传递这个id(后面称它为tid). 然后在日志打印中将tid输出,elk搜集到后,通过tid就可以查到所有日志; 现在在查看问题的时候发现mq是没有这个tid的,因此自己加入到项目中,便于之后日志查询 ---- 实际中如果发送mq的地方有tid可以加入到mq的header中;在aop中获取该tid 熟悉下aopspringboot的版本12345-- springboot的版本为id 'org.springframework.boot' version '2.3.2.RELEASE'-- aop需要引入implementation 'org.springframework.boot:spring-boot-starter-aop' 开始测试aop各个注解对应的执行顺序 验证的注解: @Before @After @Around @AfterThrowing @AfterReturning 测试代码切面1234567891011121314151617181920212223242526272829303132333435363738@Aspect@Componentpublic class TrackingNoAop {// 在项目中实际使用注解时启动报错,发现需要使用全路径,可能是公司项目包版本低的原因,不多深究// @Pointcut(&quot;@annotation(TIDLog)&quot;) @Pointcut(&quot;execution(* com.wyj.daily.test_project.controller..*.*(..))&quot;) public void aspTrackingNo(){ } //2 @Before(&quot;aspTrackingNo()&quot;) public void before(JoinPoint joinPoint) { System.out.println(&quot;before&quot;); } //4 @After(&quot;aspTrackingNo()&quot;) public void after() { System.out.println(&quot;after&quot;); } //1 @Around(&quot;aspTrackingNo()&quot;) public void around(ProceedingJoinPoint proceedingJoinPoint) throws Throwable { System.out.println(&quot;around&quot;); Object proceed = proceedingJoinPoint.proceed(proceedingJoinPoint.getArgs()); System.out.println(&quot;proceed = &quot; + proceed); } //3 @AfterThrowing(pointcut = &quot;aspTrackingNo()&quot;, throwing = &quot;e&quot;) public void afterThrowing(JoinPoint joinPoint, Exception e) { System.out.println(&quot;afterThrowing&quot;); } //3 @AfterReturning(pointcut = &quot;aspTrackingNo()&quot;) public void afterReturning() { System.out.println(&quot;afterReturning &quot;); }} 被切的类1234567@GetMapping(&quot;/testAop/{type}&quot;)public ResponseEntity&lt;String&gt; testAop(@PathVariable Integer type) { if (type == 1) { throw new RuntimeException(); } return ResponseEntity.ok(&quot;哈哈&quot;);} 正常时打印12345aroundbeforeafterReturning afterproceed = &lt;200 OK OK,哈哈,[]&gt; 抛异常时打印1234aroundbeforeafterThrowingafter 结论:请求-&gt; around开始 -&gt; before -&gt; 执行方法(proceed)-&gt; afterThrowing/afterReturning -&gt;after -&gt; around 结束 代码非mq的时候(公司之前封装的)tid的本地线程变量:1234567891011121314151617181920public class LogTreadLocal { private static final ThreadLocal&lt;String&gt; trackingNoThreadLocal = new ThreadLocal(); public LogTreadLocal() { } public static void setTrackingNo(String trackingNo) { trackingNoThreadLocal.set(trackingNo); } public static String getTrackingNo() { String trackNo = (String)trackingNoThreadLocal.get(); return trackNo; } public static void removeTrackingNo() { trackingNoThreadLocal.remove(); }} 拦截器12345678910111213141516171819public class LogTrackNoInterceptor implements HandlerInterceptor { public LogTrackNoInterceptor() { } //假设两个服务之前会传递的这个值放在header中,name为:x-transaction-id public boolean preHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o) { LogTreadLocal.setTrackingNo(StringUtils.isEmpty(httpServletRequest.getHeader(&quot;x-transaction-id&quot;)) ? UUID.randomUUID().toString().replaceAll(&quot;-&quot;, &quot;&quot;) : httpServletRequest.getHeader(&quot;x-transaction-id&quot;)); return true; } public void postHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, ModelAndView modelAndView) { } public void afterCompletion(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e) { LogTreadLocal.removeTrackingNo(); }} 日志打印时输入tid即可本次调整关于mq消费者的日志打印原本熟悉切面后,也准备放入本地线程变量中,但是公司使用logback进行日志打印, logback中有一个MDC功能,本质上也是本地线程变量,因此准备直接使用logback的MDC, 两者也不存在冲突 注解1234@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.METHOD)public @interface TIDLog {} 切面12345678910111213141516171819202122232425262728@Aspect@Component@Slf4jpublic class TrackingNoAop { @Pointcut(&quot;@annotation(com.freemud.delivery.annotation.TIDLog)&quot;) public void trackingNo() { } //2 @Before(&quot;trackingNo()&quot;) public void before(JoinPoint joinPoint) { MDC.put(&quot;tid&quot;, UUIDUtils.getUUID()); } @After(&quot;trackingNo()&quot;) public void after() { MDC.remove(&quot;tid&quot;); } @AfterThrowing(pointcut = &quot;trackingNo()&quot;, throwing = &quot;e&quot;) public void afterThrowing(Exception e) { log.error(ExceptionUtils.getFullStackOnLine(e)); }} logback调整appender-&gt;encoder-&gt;pattern下增加该tid打印,比如: &lt;pattern&gt;%d{HH:mm:ss.SSS} %contextName [%X{tid}] %-5level %logger{36} - %msg%n&lt;/pattern&gt; ​ 新增日志打印工具类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970@Slf4jpublic class LogUtils { public static BiFunction&lt;Long, Long, Long&gt; takeUpTime = (startTime, endTime) -&gt; { if (startTime != null &amp;&amp; endTime != null) { return endTime - startTime; } return null; }; public static void info(String message, Object requestData, Object responseData) { StackTraceElement stackTraceElement = Thread.currentThread().getStackTrace()[2]; log.info(&quot;ClassName: {} ,MethodName: {} , MethodLine: {}, Message: {} , RequestData: {} ,ResponseData: {}&quot;, stackTraceElement.getClassName(), stackTraceElement.getMethodName(), stackTraceElement.getLineNumber(), message, JSONObject.toJSONString(requestData), JSONObject.toJSONString(responseData) ); } public static void info(String message, Object requestData, Object responseData, Long startTime, Long endTime) { StackTraceElement stackTraceElement = Thread.currentThread().getStackTrace()[2]; log.info(&quot;ClassName: {} ,MethodName: {} , MethodLine: {} , startTime: {} , takeUpTime: {}&quot; + &quot;, Message: {} , RequestData: {} ,ResponseData: {} &quot;, stackTraceElement.getClassName(), stackTraceElement.getMethodName(), stackTraceElement.getLineNumber(), startTime, takeUpTime.apply(startTime, endTime), message, JSONObject.toJSONString(requestData), JSONObject.toJSONString(responseData) ); } public static void error(String message, Object requestData, Exception e) { StackTraceElement stackTraceElement = Thread.currentThread().getStackTrace()[2]; log.error(&quot;ClassName: {} ,MethodName: {} , MethodLine: {}, Message: {} , RequestData: {} ,ExceptionInfo: {}&quot;, stackTraceElement.getClassName(), stackTraceElement.getMethodName(), stackTraceElement.getLineNumber(), message, JSONObject.toJSONString(requestData), ExceptionUtils.getFullStackTrace(e) ); } public static void error(String message, Object requestData, Long startTime, Long endTime, Exception e) { StackTraceElement stackTraceElement = Thread.currentThread().getStackTrace()[2]; log.error(&quot;ClassName: {} ,MethodName: {} , MethodLine: {}, startTime: {} , takeUpTime: {} ,&quot; + &quot; Message: {} , RequestData: {} , ExceptionInfo: {} , &quot;, stackTraceElement.getClassName(), stackTraceElement.getMethodName(), stackTraceElement.getLineNumber(), message, JSONObject.toJSONString(requestData), startTime, takeUpTime.apply(startTime, endTime), ExceptionUtils.getFullStackTrace(e) ); }} END","link":"/2020/10/21/log%E6%89%93%E5%8D%B0%E6%97%B6%E5%A2%9E%E5%8A%A0%E9%93%BE%E8%B7%AFid/"},{"title":"quartz使用","text":"优先使用xxljob;条件不允许再考虑quartz 背景​ 有一个ka项目的定时任务服务是单节点,而这个明显是不合理的,准备搞成支持分布式的定时任务,第一个想到的xxljob;但是由于项目是运行在别人公司的服务器上,身不由己,最终选择使用quartz来进行定时任务的管理 效果​ 因为quartz是没有界面的; 之前的公司甚至见过通过查库来增加定时任务,因此希望实现的效果就是能够通过接口来对定时任务进行增删改查(界面是不可能的,只能接口了),功能如下: 新增定时任务 修改定时任务的corn表达式 暂停一个定时任务 删除一个定时任务 查询所有定时任务的列表 除此之外,我并不想太多的动之前的代码,因此尽量调整量小一些 流程 1.引包 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-quartz&lt;/artifactId&gt; &lt;/dependency&gt; 2.建表语句: 不要百度,因为quartz1.0和2.0建表不一样; 不同数据库也可能有一些差别, 建表语句在github上quartz.core包的resource下,可以先看下项目引用的版本再到github上切换对应的版本上找自己使用的数据库初始化语句,最新master分支建表的位置 3.代码编写 1.所有定时任务的枚举(后期使用这个枚举来进行定时任务的增删改查) 123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.freemud.enums;import com.freemud.extend.QuartzJobExtend;import com.freemud.quartz.CancelOrderSyncQuartz;import com.freemud.quartz.HrLinkSyncQuartz;import com.freemud.quartz.OrderSyncQuartz;import lombok.Getter;import org.springframework.util.StringUtils;@Getterpublic enum QuartzJobEnum { PULL_ORDER(1, OrderSyncQuartz.class), CANCEL_ORDER(2, CancelOrderSyncQuartz.class), HR_SYNC(3, HrLinkSyncQuartz.class), ; private Integer code; private Class&lt;? extends QuartzJobExtend&gt; clazz; QuartzJobEnum(Integer code, Class clazz) { this.code = code; this.clazz = clazz; } public static QuartzJobEnum getByCodeOrClassName(Integer code, String className) { if (code != null) { for (QuartzJobEnum value : values()) { if (value.getCode() == code) { return value; } } } if (!StringUtils.isEmpty(className)) { for (QuartzJobEnum value : values()) { if (className.equals(value.getClazz().getSimpleName())) { return value; } } } return null; }} 2.扩展下定时任务,由于没有特别的规范要求,因此这里假设 JobName默认是类的简称 GroupName默认是全称 任务描述由实现类进行说明 123456789101112131415161718192021package com.freemud.extend;import org.springframework.scheduling.quartz.QuartzJobBean;public abstract class QuartzJobExtend extends QuartzJobBean { public String getJobName() { return getClass().getSimpleName(); } public String getJobGroupName() { return getClass().getName(); } public abstract String getJobDescription(); public String getTriggerDescription() { return getJobDescription() + &quot;trigger&quot;; }} 3.定时任务 123456789101112@Component@Configuration@EnableScheduling@Slf4jpublic class CancelOrderSyncQuartz extends QuartzJobExtend { @Scheduled(cron = &quot;0 0/1 * * * ? &quot;) protected void executeQuartz() { //do something } } 改为: 1234567891011121314151617181920@Component@Configuration@EnableScheduling@Slf4jpublic class CancelOrderSyncQuartz extends QuartzJobExtend { protected void executeQuartz() { //do something } @Override public String getJobDescription() { return &quot;取消时同步定时任务&quot;; } @Override protected void executeInternal(JobExecutionContext jobExecutionContext) throws JobExecutionException { executeQuartz(); }} 至此定时任务已经正常在使用了; 但是如何初始化定时任务,如何在项目运行期间暂停/修改定时任务执行频率需要优化一下: 4.定时任务的增删改查 直接上代码; 修改定时任务同新增放在一个地方: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137package com.freemud.service;import com.freemud.commonbase.utils.SpringUtils;import com.freemud.commonbase.vo.ScheduleAddVo;import com.freemud.commonbase.vo.ScheduleDeleteVo;import com.freemud.entity.response.ScheduleResponseVo;import com.freemud.enums.QuartzJobEnum;import com.freemud.extend.QuartzJobExtend;import com.google.common.collect.Sets;import lombok.extern.slf4j.Slf4j;import org.quartz.*;import org.quartz.impl.matchers.GroupMatcher;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import org.springframework.util.CollectionUtils;import java.util.ArrayList;import java.util.List;import java.util.Set;@Slf4j@Servicepublic class ScheduleService { @Autowired private Scheduler scheduler; public void addSchedule(ScheduleAddVo scheduleAddVo) throws SchedulerException { QuartzJobEnum jobEnum = QuartzJobEnum.getByCodeOrClassName( scheduleAddVo.getCode(), scheduleAddVo.getClassName()); if (jobEnum == null) { return; } QuartzJobExtend jobExtend = SpringUtils.getBean(jobEnum.getClazz()); TriggerKey triggerKey = TriggerKey.triggerKey(jobExtend.getJobName(), jobExtend.getJobGroupName()); CronTrigger cronTrigger = TriggerBuilder.newTrigger() .withIdentity(triggerKey) .withDescription(jobExtend.getJobDescription()) .withSchedule( CronScheduleBuilder.cronSchedule(scheduleAddVo.getCornExpressoin()) .withMisfireHandlingInstructionDoNothing() ).build(); //进行更新操作 if (scheduler.checkExists(triggerKey)) { JobKey jobKey = new JobKey(jobExtend.getJobName(), jobExtend.getJobGroupName()); JobDetail jobDetail = scheduler.getJobDetail(jobKey); jobDetail.getJobBuilder().withDescription(jobExtend.getJobDescription()); scheduler.scheduleJob(jobDetail, Sets.newHashSet(cronTrigger), true); }else{ //执行新增操作 JobDetail jobDetail = JobBuilder.newJob(jobExtend.getClass()) .withDescription(jobExtend.getJobDescription()) .withIdentity(jobExtend.getJobName(), jobExtend.getJobGroupName()) .build(); scheduler.scheduleJob(jobDetail, cronTrigger); } } public void deleteSchedule(ScheduleDeleteVo scheduleDeleteVo) throws SchedulerException { QuartzJobEnum jobEnum = QuartzJobEnum.getByCodeOrClassName( scheduleDeleteVo.getCode(), scheduleDeleteVo.getClassName()); if (jobEnum == null) { return; } QuartzJobExtend jobExtend = SpringUtils.getBean(jobEnum.getClazz()); TriggerKey triggerKey = TriggerKey.triggerKey(jobExtend.getJobName(), jobExtend.getJobGroupName()); if (scheduler.checkExists(triggerKey)) { scheduler.pauseTrigger(triggerKey); scheduler.unscheduleJob(triggerKey); } } public List&lt;ScheduleResponseVo&gt; listAllSchedule() throws SchedulerException { List&lt;ScheduleResponseVo&gt; result = new ArrayList&lt;&gt;(); List&lt;String&gt; jobGroupNames = scheduler.getJobGroupNames(); if (CollectionUtils.isEmpty(jobGroupNames)) { return result; } for (String jobGroupName : jobGroupNames) { Set&lt;JobKey&gt; jobKeySet = scheduler.getJobKeys(GroupMatcher.jobGroupEquals(jobGroupName)); if (CollectionUtils.isEmpty(jobKeySet)) { continue; } for (JobKey jobKey : jobKeySet) { ScheduleResponseVo responseVo = new ScheduleResponseVo(); JobDetail jobDetail = scheduler.getJobDetail(jobKey); TriggerKey triggerKey = TriggerKey.triggerKey(jobKey.getName(), jobGroupName); Trigger trigger = scheduler.getTrigger(triggerKey); ScheduleResponseVo.JobDetail jobDetailResponse = responseVo.new JobDetail(); jobDetailResponse.setJobName(jobKey.getName()); jobDetailResponse.setJobClass(jobDetail.getJobClass().getName()); jobDetailResponse.setJobGroupName(jobGroupName); jobDetailResponse.setDescription(jobDetail.getDescription()); responseVo.setJobDetail(jobDetailResponse); ScheduleResponseVo.Trigger triggerResponse = responseVo.new Trigger(); triggerResponse.setDescription(trigger.getDescription()); triggerResponse.setStartTime(trigger.getStartTime()); triggerResponse.setNextTime(trigger.getNextFireTime()); if (trigger instanceof CronTrigger) { CronTrigger cronTrigger = (CronTrigger) trigger; triggerResponse.setCornExpression(cronTrigger.getCronExpression()); triggerResponse.setExpressionSummary(cronTrigger.getExpressionSummary()); } Trigger.TriggerState triggerState = scheduler.getTriggerState(triggerKey); triggerResponse.setStatus(triggerState.toString()); responseVo.setTrigger(triggerResponse); result.add(responseVo); } } return result; } public void pauseSchedule(Integer code) throws SchedulerException { QuartzJobEnum quartzJobEnum = QuartzJobEnum.getByCodeOrClassName(code, null); QuartzJobExtend jobExtend = SpringUtils.getBean(quartzJobEnum.getClazz()); TriggerKey triggerKey = TriggerKey.triggerKey(jobExtend.getJobName(), jobExtend.getJobGroupName()); if (scheduler.checkExists(triggerKey)) { scheduler.pauseTrigger(triggerKey); } }} 查询定时任务时返回的实体类如下: 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.freemud.entity.response;import lombok.Data;import java.util.Date;@Datapublic class ScheduleResponseVo { private JobDetail jobDetail; private Trigger trigger; @Data public class JobDetail { private String jobName; private String jobGroupName; private String jobClass; private String description; } @Data public class Trigger { private String cornExpression; private String expressionSummary; private String description; private Date startTime; private Date nextTime; private String status; }} 然后在controller中进行调用即可; 1234567891011121314151617181920212223242526272829303132@RestController@RequestMapping(&quot;/schedule&quot;)public class ScheduleController { @Autowired private ScheduleService scheduleService; @PostMapping(&quot;/add&quot;) public BaseResponse addSchedule(@RequestBody ScheduleAddVo scheduleAddVo) throws SchedulerException { scheduleService.addSchedule(scheduleAddVo); return ResponseUtil.success(); } @DeleteMapping public BaseResponse deleteSchedule(@RequestBody ScheduleDeleteVo scheduleDeleteVo) throws SchedulerException { scheduleService.deleteSchedule(scheduleDeleteVo); return ResponseUtil.success(); } @GetMapping public BaseResponse getSchedule() throws SchedulerException { return ResponseUtil.success(scheduleService.listAllSchedule()); } @PostMapping(&quot;/pause/{code}&quot;) public BaseResponse pauseSchedule(@PathVariable Integer code) throws SchedulerException { scheduleService.pauseSchedule(code); return ResponseUtil.success(); }} - 新增(同修改)时通过传入code或者类名来进行设置定时任务的执行如: 1234{ &quot;code&quot;: 2, &quot;cornExpressoin&quot; : &quot;0 */1 * * * ?&quot;} - 查询的效果: 1234567891011121314151617181920212223242526272829303132333435363738{ &quot;code&quot;: 100, &quot;msg&quot;: &quot;success&quot;, &quot;data&quot;: [ { &quot;jobDetail&quot;: { &quot;jobName&quot;: &quot;CancelOrderSyncQuartz$$EnhancerBySpringCGLIB$$df76ceae&quot;, &quot;jobGroupName&quot;: &quot;com.freemud.quartz.CancelOrderSyncQuartz$$EnhancerBySpringCGLIB$$df76ceae&quot;, &quot;jobClass&quot;: &quot;com.freemud.quartz.CancelOrderSyncQuartz$$EnhancerBySpringCGLIB$$df76ceae&quot;, &quot;description&quot;: &quot;取消同步&quot; }, &quot;trigger&quot;: { &quot;cornExpression&quot;: &quot;*/5 * * * * ?&quot;, &quot;expressionSummary&quot;: &quot;seconds: 0,5,10,15,20,25,30,35,40,45,50,55\\nminutes: *\\nhours: *\\ndaysOfMonth: *\\nmonths: *\\ndaysOfWeek: ?\\nlastdayOfWeek: false\\nnearestWeekday: false\\nNthDayOfWeek: 0\\nlastdayOfMonth: false\\nyears: *\\n&quot;, &quot;description&quot;: &quot;取消同步&quot;, &quot;startTime&quot;: &quot;2020-11-11T05:41:16.000+0000&quot;, &quot;nextTime&quot;: &quot;2020-11-11T05:42:15.000+0000&quot;, &quot;status&quot;: &quot;NORMAL&quot; } }, { &quot;jobDetail&quot;: { &quot;jobName&quot;: &quot;OrderSyncQuartz&quot;, &quot;jobGroupName&quot;: &quot;com.freemud.quartz.OrderSyncQuartz&quot;, &quot;jobClass&quot;: &quot;com.freemud.quartz.OrderSyncQuartz&quot;, &quot;description&quot;: &quot;拉单定时任务&quot; }, &quot;trigger&quot;: { &quot;cornExpression&quot;: &quot;0 */1 * * * ?&quot;, &quot;expressionSummary&quot;: &quot;seconds: 0\\nminutes: 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59\\nhours: *\\ndaysOfMonth: *\\nmonths: *\\ndaysOfWeek: ?\\nlastdayOfWeek: false\\nnearestWeekday: false\\nNthDayOfWeek: 0\\nlastdayOfMonth: false\\nyears: *\\n&quot;, &quot;description&quot;: &quot;拉单定时任务&quot;, &quot;startTime&quot;: &quot;2020-11-11T05:42:11.000+0000&quot;, &quot;nextTime&quot;: &quot;2020-11-11T05:43:00.000+0000&quot;, &quot;status&quot;: &quot;PAUSE&quot; } } ]}","link":"/2020/11/11/quartz%E4%BD%BF%E7%94%A8/"},{"title":"springretry","text":"重试有很多方式,但是spring的肯定会比较香吧 参考文章/连接 Java实现几种简单的重试机制 spring-retry 源码README.md spring-retry（1.概念和基本用法） 背景 项目之前有一段代码 123456789101112131415 public void syncPosByDelivery(DeliveryStatusDto dto, int retryNum) { try { if (retryNum &lt; 2) { Response response = retryThree(dto, System.currentTimeMillis()); if (!Objects.equals(response.code(), 204)) { Thread.sleep(5000L); retryNum++; syncPosByDelivery(dto, retryNum); } } } catch (InterruptedException e) { e.printStackTrace(); }} 代码实现了重试三次的功能; 现在需求是三方接口可能会有超时;如果超时就重试.上述代码虽然可以实现;但是我觉得实现方法不应该这么粗暴.上网搜到了Java实现几种简单的重试机制这篇文章后,准备选用spring-retry来实现我的功能 原因无它,因为这是spring出产的… 官方文档快速上手学习下 非注解使用 主要学习下基本概念; 主要是:RetryContext/*RetryPolicy/RecoveryCallback/RetryCallback 重试时间策略: 12345678910111213141516@Testpublic void springRetry1() throws Throwable { RetryTemplate retryTemplate = new RetryTemplate(); TimeoutRetryPolicy policy = new TimeoutRetryPolicy(); policy.setTimeout(3000L); retryTemplate.setRetryPolicy(policy); Object execute = retryTemplate.execute((RetryCallback&lt;Object, Throwable&gt;) context -&gt; { TimeUnit.SECONDS.sleep(1); throw new RuntimeException(); }); System.out.println(&quot;execute = &quot; + execute);} 增加重试后补偿12345678910111213141516171819@Testpublic void springRetry2() throws Throwable { RetryTemplate retryTemplate = new RetryTemplate(); TimeoutRetryPolicy policy = new TimeoutRetryPolicy(); policy.setTimeout(3000L); retryTemplate.setRetryPolicy(policy); Object execute = retryTemplate.execute((RetryCallback&lt;Object, Throwable&gt;) context -&gt; { TimeUnit.SECONDS.sleep(1); throw new RuntimeException(); }, context -&gt; { return &quot;recoveryCallBack&quot;; }); System.out.println(&quot;execute = &quot; + execute);} 重试次数策略 1234567891011121314151617181920 @Testpublic void springRetry3() throws Throwable { RetryTemplate build = RetryTemplate.builder() .maxAttempts(3) //执行的时间执行 .fixedBackoff(1000) .retryOn(IllegalArgumentException.class) .build(); Object execute = build.execute(context -&gt; { // business logic here throw new RuntimeException(); }, (RecoveryCallback&lt;Object&gt;) context -&gt; { // recover logic here return &quot;111&quot;; }); System.out.println(&quot;execute = &quot; + execute);} 重试次数策略2: 12345678910111213141516171819202122232425 @Testpublic void springRetry4(){ RetryTemplate retryTemplate = new RetryTemplate(); SimpleRetryPolicy simpleRetryPolicy = new SimpleRetryPolicy(3, Collections.singletonMap(SocketTimeoutException.class, true)); retryTemplate.setRetryPolicy(simpleRetryPolicy); FixedBackOffPolicy backOffPolicy = new FixedBackOffPolicy(); backOffPolicy.setBackOffPeriod(1000L); retryTemplate.setBackOffPolicy(backOffPolicy); RetryContext execute = null; try { execute = retryTemplate.execute(context -&gt; { RetryContextCache retryContextCache = new MapRetryContextCache(); retryContextCache.put(&quot;eee&quot;, context); throw new RuntimeException(&quot;&quot;); }); } catch (RuntimeException e) { System.out.println(&quot;ExceptionUtils.getFullExceptionLine(e) = &quot; + ExceptionUtils.getFullExceptionLine(e)); } System.out.println(&quot;execute = &quot; + execute);} 注解使用 和非注解使用特别相同;然后按照文档上又额外学习下listener的使用 12345678910111213141516171819202122232425262728293031323334353637383940//自定义的listener @Beanpublic RetryListener retryListerner1() { return new RetryListener() { @Override public &lt;T, E extends Throwable&gt; boolean open(RetryContext context, RetryCallback&lt;T, E&gt; callback) { log.info(&quot;open &quot;); logAttributeName(&quot;open&quot;, context); return true; } @Override public &lt;T, E extends Throwable&gt; void close(RetryContext context, RetryCallback&lt;T, E&gt; callback, Throwable throwable) { log.info(&quot;close&quot;); logAttributeName(&quot;close&quot;,context); } @Override public &lt;T, E extends Throwable&gt; void onError(RetryContext context, RetryCallback&lt;T, E&gt; callback, Throwable throwable) { log.info(&quot;onError&quot;); logAttributeName(&quot;onError&quot;, context); } };}public static void logAttributeName(String methodName,RetryContext retryContext) { log.info(&quot;methodName : {} start&quot;, methodName); log.info(&quot;retryName : &quot; + retryContext.getAttribute(RetryContext.NAME)); for (String attributeName : retryContext.attributeNames()) { log.info(attributeName + &quot;: &quot; + retryContext.getAttribute(attributeName)); } log.info(&quot;methodName : {} end&quot;, methodName);}@Beanpublic RetryListener retryListerner2(){ return new StatisticsListener(new DefaultStatisticsRepository());} listener是用于接收到每次重试不同状态的通知;源码中默认应该是实例中的retryListerner2 注解使用 123456@Retryable(listeners = &quot;retryListerner1&quot;, maxAttempts = 2, backoff = @Backoff(delay = 100, maxDelay = 500)) public void retry() throws BaseException { throw new BaseException(&quot;retry&quot;); } 看一下listerner的调用顺序以及retryContext有哪些属性 1234567891011121314151617181920212223242526272829 23:08:19.928 test_project [] WARN o.s.r.policy.ExpressionRetryPolicy - #{...} syntax is not required for this run-time expression and is deprecated in favor of a simple expression string23:08:19.959 test_project [] INFO c.w.d.t.config.RetryConfig - open 23:08:19.959 test_project [] INFO c.w.d.t.config.RetryConfig - methodName : open start23:08:19.960 test_project [] INFO c.w.d.t.config.RetryConfig - retryName : null23:08:19.960 test_project [] INFO c.w.d.t.config.RetryConfig - methodName : open end23:08:19.970 test_project [] INFO c.w.d.t.config.RetryConfig - onError23:08:19.971 test_project [] INFO c.w.d.t.config.RetryConfig - methodName : onError start23:08:19.971 test_project [] INFO c.w.d.t.config.RetryConfig - retryName : public void com.wyj.daily.test_project.service.RetryService.retryException() throws com.wyj.daily.commonbase.exception.BaseException23:08:19.971 test_project [] INFO c.w.d.t.config.RetryConfig - context.name: public void com.wyj.daily.test_project.service.RetryService.retryException() throws com.wyj.daily.commonbase.exception.BaseException23:08:19.971 test_project [] INFO c.w.d.t.config.RetryConfig - methodName : onError end23:08:20.988 test_project [] INFO c.w.d.t.config.RetryConfig - onError23:08:20.988 test_project [] INFO c.w.d.t.config.RetryConfig - methodName : onError start23:08:20.988 test_project [] INFO c.w.d.t.config.RetryConfig - retryName : public void com.wyj.daily.test_project.service.RetryService.retryException() throws com.wyj.daily.commonbase.exception.BaseException23:08:20.988 test_project [] INFO c.w.d.t.config.RetryConfig - context.name: public void com.wyj.daily.test_project.service.RetryService.retryException() throws com.wyj.daily.commonbase.exception.BaseException23:08:20.988 test_project [] INFO c.w.d.t.config.RetryConfig - methodName : onError end23:08:21.990 test_project [] INFO c.w.d.t.config.RetryConfig - onError23:08:21.990 test_project [] INFO c.w.d.t.config.RetryConfig - methodName : onError start23:08:21.990 test_project [] INFO c.w.d.t.config.RetryConfig - retryName : public void com.wyj.daily.test_project.service.RetryService.retryException() throws com.wyj.daily.commonbase.exception.BaseException23:08:21.990 test_project [] INFO c.w.d.t.config.RetryConfig - context.name: public void com.wyj.daily.test_project.service.RetryService.retryException() throws com.wyj.daily.commonbase.exception.BaseException23:08:21.990 test_project [] INFO c.w.d.t.config.RetryConfig - methodName : onError end23:08:21.990 test_project [] INFO c.w.d.t.service.RetryService - -----------------------23:08:21.990 test_project [] INFO c.w.d.t.config.RetryConfig - close23:08:21.990 test_project [] INFO c.w.d.t.config.RetryConfig - methodName : close start23:08:21.990 test_project [] INFO c.w.d.t.config.RetryConfig - retryName : public void com.wyj.daily.test_project.service.RetryService.retryException() throws com.wyj.daily.commonbase.exception.BaseException23:08:21.990 test_project [] INFO c.w.d.t.config.RetryConfig - context.name: public void com.wyj.daily.test_project.service.RetryService.retryException() throws com.wyj.daily.commonbase.exception.BaseException23:08:21.990 test_project [] INFO c.w.d.t.config.RetryConfig - context.exhausted: true23:08:21.990 test_project [] INFO c.w.d.t.config.RetryConfig - context.recovered: true23:08:21.990 test_project [] INFO c.w.d.t.config.RetryConfig - context.closed: true23:08:21.990 test_project [] INFO c.w.d.t.config.RetryConfig - methodName : close end 加入recover使用123456789@Retryable(recover = &quot;recover&quot;, value = BaseException.class)public void retryRecover() { throw new BaseException(&quot;retry&quot;);}@Recoverpublic void recover(BaseException e) { log.info(&quot;-----------------------&quot;);} spel表达式:官方文档中指出在注解中可以使用spel表达式; 如下:12345678910111213141516@Retryable(exceptionExpression=&quot;message.contains('this can be retried')&quot;)public void service1() { ...}@Retryable(exceptionExpression=&quot;message.contains('this can be retried')&quot;)public void service2() { ...}@Retryable(exceptionExpression=&quot;@exceptionChecker.shouldRetry(#root)&quot;, maxAttemptsExpression = &quot;#{@integerFiveBean}&quot;, backoff = @Backoff(delayExpression = &quot;#{1}&quot;, maxDelayExpression = &quot;#{5}&quot;, multiplierExpression = &quot;#{1.1}&quot;))public void service3() { ...} 之前对表达式没有深入了解到,因此下面exceptionChecker.shouldRetry(#root)这一个看不懂; 不知道是不是大多数人都知道…总之我百度不出来,然后看了下spel表达式后简单解释下上面的用例: 1234message.contains('this can be retried') -&gt; 假设抛出异常为e;那么e.getMessage().contains('this can be retried')@exceptionChecker.shouldRetry(#root) -&gt;有一个name为exceptionChecker的bean; bean中有一个方法为shoudRetry;入参是是这个异常本身 注意 : 其他代码可以cv; 如果上面那个代码直接cv是会抛出spel相关Exception;如果坚持使用;请加入下面代码1234567891011121314151617public static class ExceptionChecker { public boolean shouldRetry(Throwable t) { return true; }} //并在项目中引入该bean;@Beanpublic ExceptionChecker exceptionChecker() { return new ExceptionChecker();} //同理可得 integerFiveBean也是一个bean@Beanpublic Integer integerFiveBean() { return Integer.valueOf(5);} 配置文件中加入其他变量","link":"/2020/10/28/springretry/"},{"title":"typora使用","text":"安利下 typora 这个markdown编辑工具 界面简洁,功能强大 对于普通的markdown语法不在描述,不过我迷上了写流程图,为什么是写流程图不是画,是因为真的就是写出来的图 直接上用例 时序图1234567891011sequenceDiagramloop 定时任务达美乐tracker系统 -&gt;&gt; 聚合服务 : 拉单(外送单)end聚合服务 -&gt;&gt; 聚合服务 : 通过mq实现延迟推送聚合服务 -&gt;&gt; 配送服务: 推单配送服务 -&gt;&gt; 配送服务: 自配送配送服务 -&gt;&gt; 顺丰服务 : 推送运单顺丰服务 --&gt;&gt; 配送服务 : 状态回调配送服务 --&gt;&gt; 聚合服务 : 状态回调聚合服务 --&gt;&gt; 达美乐plus系统 : plus回报 对应的实际效果图: 来一张给我下需求时的时序图1234567891011121314151617181920212223242526272829303132333435363738sequenceDiagram顾客-&gt;&gt;tracker: 下单loop 正向流程配送系统-&gt;&gt;tracker: 一分钟拉取一次订单tracker--&gt;&gt;配送系统: 拉取到`存餐状态`订单配送系统-&gt;&gt;tracker: 一分钟拉取一次订单，获取`取餐码`、`取餐柜订单号`、`柜号`tracker--&gt;&gt;配送系统: 返回配送系统-&gt;&gt;骑手APP: 信鸽推送`取餐码`、`取餐柜订单号`和`柜号`骑手APP-&gt;&gt;配送系统: 一键取餐配送系统-&gt;&gt;东城: 拿`取餐柜订单号`、`验签信息`开柜取餐（接口：`5. 远程开箱`）东城--&gt;&gt;配送系统:取餐成功配送系统--&gt;&gt;骑手APP: 更新取餐状态（取餐成功，置灰）配送系统-&gt;&gt;配送系统: 第三方骑手接单，获取骑手手机号配送系统-&gt;&gt;EC短信平台: 短信推送`取餐码`和`柜号`给第三方骑手手机号EC短信平台-&gt;&gt;第三方骑手:通知`取餐码`、`柜号`第三方骑手-&gt;&gt;东城:拿`取餐码`取餐loop 线下的东城校验流程东城--&gt;&gt;东城:拿`取餐码`开柜取餐，返回成功与否end东城--&gt;&gt;第三方骑手:开柜成功&amp;失败endloop 逆向流程tracker--&gt;&gt;配送系统: 拉取到`取消存餐状态`订单配送系统-&gt;&gt;EC短信平台: 短信通知给第三方骑手手机号EC短信平台-&gt;&gt;第三方骑手:通知骑手取消存餐配送系统-&gt;&gt;骑手APP: 信鸽推送取消存餐，一键取餐按钮置灰骑手APP-&gt;&gt;配送系统: 一键取餐（停留在订单页面未离开）配送系统--&gt;&gt;东城: 拿`取餐柜订单号`、`验签信息`开柜取餐（接口：`5. 远程开箱`）东城--&gt;&gt;配送系统:取餐失败配送系统--&gt;&gt;骑手APP: 取餐失败，更新按钮`置灰`endloop 补偿流程骑手APP-&gt;&gt;配送系统:开始配送配送系统--&gt;&gt;配送系统: 判断当前批次已`一键取餐`配送系统--&gt;&gt;骑手APP: 开始配送成功，当前批次进入配送中配送系统--&gt;&gt;配送系统: 判断当前批次有运单未`一键取餐`配送系统--&gt;&gt;骑手APP: 开始配送失败，提示：`还有订单未取餐，请先取餐`end 实际效果(图太大,截不了全图,可以自己试试): 流程图1234567891011graph TD新运单 --&gt; 首次分配首次分配 -- 空闲骑手 --&gt; FIRST[直接分配] --&gt; 结束首次分配 -- 待单数之内 --&gt; 创建新的批次或者并单 --&gt; 结束首次分配 -- 待单数之外 --&gt; 顺丰 -- 配送方案最长接单时间 --&gt; 取消创建新运单推送自配送--空闲骑手--&gt; SECOND[直接分配]--&gt; 结束取消创建新运单推送自配送 -- 可以并单 --&gt; 直接并入批次--&gt; 结束取消创建新运单推送自配送 -- 不可以并单 --&gt; 创建新的批次 --&gt; 结束 这张图确实丑了点,嗯,我现在还不熟练,但是这个流程称得上很清晰了","link":"/2020/11/20/typora%E4%BD%BF%E7%94%A8/"},{"title":"双数据源实现方式二-区分包扫描方式","text":"[toc] 双数据源第二种方法 上文写到的第一种方法aop没有切到父类方法,解决方法也有多种;可以百度搜下; 这篇文章的方案是: 不同的包对应不同的数据源 ; 这种访问的重点就是配置.配置只要对了; 就很简单 step1:配置datasource/mapperscanner/sqlsessionfactory注意将原先的@MapperScan注解干掉,下面会自定义 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061@Bean(&quot;sqlServerDS&quot;)@Primary@ConfigurationProperties(prefix = &quot;sqlserver.datasource&quot;)public DataSource sqlServerDS() { return DataSourceBuilder.create().type(HikariDataSource.class).build();}@Bean(&quot;mysqlDS&quot;)@ConfigurationProperties(prefix = &quot;mysql.datasource&quot;)public DataSource mysqlDS() { return DataSourceBuilder.create().type(HikariDataSource.class).build();}@Primary@Beanpublic SqlSessionFactory sqlServerSqlSessionFactory(@Qualifier(&quot;sqlServerDS&quot;) DataSource dataSource) throws Exception { SqlSessionFactoryBean factoryBean = new SqlSessionFactoryBean(); factoryBean.setDataSource(dataSource); return factoryBean.getObject();}@Beanpublic SqlSessionFactory mysqlSqlSessionFactory(@Qualifier(&quot;mysqlDS&quot;) DataSource dataSource) throws Exception { SqlSessionFactoryBean factoryBean = new SqlSessionFactoryBean(); factoryBean.setDataSource(dataSource); return factoryBean.getObject();}@Beanpublic MapperScannerConfigurer sqlServerMapperScanner() { MapperScannerConfigurer sqlServerMapperScanner = new MapperScannerConfigurer(); sqlServerMapperScanner.setSqlSessionFactoryBeanName(&quot;sqlServerSqlSessionFactory&quot;); sqlServerMapperScanner.setBasePackage(&quot;com.freemud.order.dao.sqlserver&quot;); Properties properties = new Properties(); properties.setProperty(&quot;mappers&quot;, Mapper.class.getName()); properties.setProperty(&quot;notEmpty&quot;, &quot;false&quot;); properties.setProperty(&quot;IDENTITY&quot;, &quot;SqlServer&quot;); sqlServerMapperScanner.setProperties(properties); return sqlServerMapperScanner;}@Beanpublic MapperScannerConfigurer mysqlMapperScanner() { MapperScannerConfigurer sqlServerMapperScanner = new MapperScannerConfigurer(); sqlServerMapperScanner.setSqlSessionFactoryBeanName(&quot;mysqlSqlSessionFactory&quot;); sqlServerMapperScanner.setBasePackage(&quot;com.freemud.order.dao.mysql&quot;); Properties properties = new Properties(); properties.setProperty(&quot;mappers&quot;, Mapper.class.getName()); properties.setProperty(&quot;notEmpty&quot;, &quot;false&quot;); properties.setProperty(&quot;IDENTITY&quot;, &quot;MySQL&quot;); sqlServerMapperScanner.setProperties(properties); return sqlServerMapperScanner;} step2: 整理自己的代码分层比如将原先的dao 分为dao.mysql; 和dao.sqlserver; 不同的数据源对应不同的包这样子 step3: 代码使用本次使用的场景是数据库逐步迁移; 因此做了黑白名单,默认sqlserver; 上了名单走mysql 123456789public BaseResponse queryOrderListByTime(OrderVo vo) { List&lt;? extends OrderDto&gt; orderDtos ; if (vo.getDsTypeEnum() == DSTypeEnum.SQLSERVER) { orderDtos = orderDao.selectByOrderVo(vo); }else{ orderDtos = mySqlOrderDao.selectByOrderVo(vo); } return ResponseUtil.success(orderDtos); } 注意事项 不同的datasource的配置略有不同,比如durid的是url; 而HikariDataSource是jdbc-url 项目中原先的@MapperScan要干掉; MapperScannerConfigurer这个要注意; 因为代码有一定演示意义在内,实际中如果你继承的不是Mapper;而是自定义的需要加到这里面; 多个就用逗号隔开","link":"/2020/11/20/%E5%8F%8C%E6%95%B0%E6%8D%AE%E6%BA%90%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E4%BA%8C-%E5%8C%BA%E5%88%86%E5%8C%85%E6%89%AB%E6%8F%8F%E6%96%B9%E5%BC%8F/"},{"title":"双数据源实现方式一-注解方式","text":"[toc] 结论放前面目前我知道两种实现双数据源的方式; 实现难度都不大 先把个人的结论写前面 通过aop + 注解的形式在切面切换数据源实现 优势: 对本身的代码分层没有任何变化.即两个数据源对应的entity/repository不变 劣势: aop切父类方法会失效;即:如果使用通用mapper则会导致父类方法没切到 通过不同数据源扫描不同的包实现 优势: 只关心实体类对应包即可,不需要额外增加注解 劣势:有一定的侵入; 比如原本dao在repository包下,现在需要再建一个;比如原先的迁移到dao.primary包下; 第二数据源放在dao.second包下 第一种方式: aop+注解流程效果 : 调用repository层方法前;通过切面切换数据源; 直接撸代码 step1 增加注解:因为一个repository类不应该同时对应两个数据库; 应该注解指定定义类使用即可 12345678@Documented@Retention(RetentionPolicy.RUNTIME)@Target(value = {ElementType.TYPE})public @interface DataSourceType { DBTypeEnum value() default DBTypeEnum.PRIMARY;} 同时定义下两种不同数据源的枚举 12345678910@Getterpublic enum DBTypeEnum { PRIMARY(&quot;primaryDb&quot;), LOG(&quot;logDb&quot;),; private String dbName; DBTypeEnum(String dbName) { this.dbName = dbName; }} step2 动态数据源123456789spring.datasource.druid.url=jdbc:mysql://127.0.0.1:3306/sharding_0?useUnicode=true&amp;characterEncoding=UTF-8&amp;allowMultiQueries=true&amp;useSSL=false&amp;serverTimezone=UTCspring.datasource.druid.username=rootspring.datasource.druid.password=rootspring.datasource.druid.driver-class-name=com.mysql.cj.jdbc.Driverspring.datasource.log.url=jdbc:mysql://127.0.0.1:3306/sharding_1?useUnicode=true&amp;characterEncoding=UTF-8&amp;allowMultiQueries=true&amp;useSSL=false&amp;serverTimezone=UTCspring.datasource.log.username=rootspring.datasource.log.password=rootspring.datasource.log.driver-class-name=com.mysql.cj.jdbc.Driver 1234567891011121314151617181920212223242526272829303132333435@Bean@Primary@ConfigurationProperties(&quot;spring.datasource.druid&quot;)public DataSource primaryDb() { return DruidDataSourceBuilder.create().build();}@Bean@ConfigurationProperties(&quot;spring.datasource.log&quot;)public DataSource logDb() { return DruidDataSourceBuilder.create().build();}@Beanpublic DynamicDataSource dynamicDataSource(@Qualifier(&quot;primaryDb&quot;) DataSource primaryDb, @Qualifier(&quot;logDb&quot;) DataSource logDb) { Map&lt;Object, Object&gt; targetDataSources = new HashMap&lt;&gt;(); targetDataSources.put(DBTypeEnum.PRIMARY, primaryDb); targetDataSources.put(DBTypeEnum.LOG, logDb); return new DynamicDataSource(primaryDb, targetDataSources);}/** * 低版本中SqlSessionFactory会自动注入; 高版本取消了sqlsessionfactory的自动注入; 需要自己手动注入 * @param dynamicDataSource * @return * @throws Exception */@Beanpublic SqlSessionFactory sqlSessionFactory(DynamicDataSource dynamicDataSource) throws Exception { final SqlSessionFactoryBean sessionFactory = new SqlSessionFactoryBean(); sessionFactory.setDataSource(dynamicDataSource); return sessionFactory.getObject();} 123456789101112131415161718192021public class DynamicDataSource extends AbstractRoutingDataSource { private static final ThreadLocal&lt;DBTypeEnum&gt; DB_HOLDER = new ThreadLocal&lt;&gt;(); public DynamicDataSource(DataSource defaultTargetDataSource, Map&lt;Object, Object&gt; targetDataSource) { super.setDefaultTargetDataSource(defaultTargetDataSource); super.setTargetDataSources(targetDataSource); super.afterPropertiesSet(); } @Override protected Object determineCurrentLookupKey() { return DB_HOLDER.get(); } public static void setDBType(DBTypeEnum dbType) { DB_HOLDER.set(dbType); } public static DBTypeEnum getDBType() { return DB_HOLDER.get(); } public static void clearDBType() { DB_HOLDER.remove(); }} step3 定义aop1234567891011121314@Before(value = &quot;execution(* com.daily.multipledatasource01.repository..*.*(..))&quot;) public void doBefore(JoinPoint joinPoint) { Class targetClass = joinPoint.getSignature().getDeclaringType(); DataSourceType annotation = AnnotationUtils.findAnnotation(targetClass, DataSourceType.class); if (annotation != null) { DynamicDataSource.setDBType(annotation.value()); } } @After(value = &quot;execution(* com.daily.multipledatasource01.repository..*.*(..))&quot;) public void doAfter(JoinPoint joinPoint) { DynamicDataSource.clearDBType(); } step4 代码使用父类方法的接口没有切到,所以暂时先写一个新的方法跑通流程 123456@DataSourceType(DBTypeEnum.LOG)public interface OrderLogRepository extends Mapper&lt;OrderLog&gt; { default int save(OrderLog orderLog) { return insert(orderLog); }}","link":"/2020/11/20/%E5%8F%8C%E6%95%B0%E6%8D%AE%E6%BA%90%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E4%B8%80-%E6%B3%A8%E8%A7%A3%E6%96%B9%E5%BC%8F/"},{"title":"延时队列的不同实现形式","text":"项目背景 客户的数据不推送到我们服务中,创建配送单的方式是手动拉他们的数据创建配送单;门店有一个制作时间,因此会设置一个延迟推送时间(可配置); 如下单6分钟后该创建该运单的配送单 历史做法 创建一个定时任务; 1分钟拉取一次数据; 将符合条件的数据设置超时时间放到一个无消费者的队列中 队列延时时间到了之后, 丢入死信队列中 死信队列的消费者会先查该运单是否创建过(因为6分钟可能被拉取到6次); 如果没有创建过则创建一条运单 改造原因(主要还是第二条) 1.上述提到的6分钟可配置; 由于是一个定制化商户;这个商户曾连续修改这个值;已经有了延迟1,3,5,6,7,8,9,10,15,30,60这么多延时的死信队列了; 还提出有新的延迟时间 2.逻辑已经上线N个月了; 我刚接手一个月说这个时间不准确; 延迟6分钟; 但是他们看到的是超过了6分钟多了几秒; 感觉在欺负我一样 3.代码太乱了; 因为每一个延迟时间就创建两个队列; 在声明的类中代码太长;接手就发现7分钟的延迟对了用的是五分钟的配置.查问题不好查 改造方式1(客户需要配合) 要求: 1.mq版本升级到3.6以上 (项目已支持)2.安装动态延迟队列插件: rabbitmq_delayed_message_exchange 实现 创建队列1234567891011121314151617 @Bean CustomExchange multipleDelayExchange(){ Map&lt;String, Object&gt; args = new HashMap&lt;&gt;(); args.put(&quot;x-delayed-type&quot;, &quot;direct&quot;); return new CustomExchange(DELAY_EXCHANGE, &quot;x-delayed-message&quot;, true, false, args); } @Bean Queue multipleDelayQueue() { return new Queue(DELAY_QUEUE, true); } @Bean Binding multipleDelayBinding() { return BindingBuilder.bind(multipleDelayQueue()) .to(multipleDelayExchange()) .with(DELAY_ROUTING) .noargs(); } 消费者12345 @RabbitListener(queues = MultiplexDlConfig.DELAY_QUEUE) public void consumer(String msg, Message message) { log.info(&quot;当前时间: {} ,message : {} &quot;, LocalDateTime.now(), message); } 发送端123456789101112 @PostMapping(&quot;/send&quot;) public ResponseEntity&lt;String&gt; multipleDlSendMsg(@RequestBody MultipleDlRequest multipleDlRequest) { rabbitTemplate.convertAndSend(MultiplexDlConfig.DELAY_EXCHANGE, MultiplexDlConfig.DELAY_ROUTING, multipleDlRequest.getMessage(), msg -&gt; { log.info(&quot;当前时间: {} ,msg : {} &quot;, LocalDateTime.now(), msg); Integer delayTime = multipleDlRequest.getDlTime() * 1000; msg.getMessageProperties().setHeader(&quot;x-delay&quot;, delayTime); return msg; }); return ResponseEntity.ok(&quot;ok&quot;); } 方式2(客户不配合) 客户要是配合的话也不会出现定时拉取他们数据这种情况, 所以上面的是主要方案; 这个是备选方案 参考地址:有赞延迟队列设计demo已经写过; 对于wait/notify因为需求又来了一批;回头尝试下 总结下延迟队列的实现形式 不考虑延时的实时性; 使用定时任务+死信队列 使用mq延时队列 redis的zset来实现延时队列","link":"/2020/09/27/%E5%BB%B6%E6%97%B6%E9%98%9F%E5%88%97/"}],"tags":[{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"quartz","slug":"quartz","link":"/tags/quartz/"},{"name":"markdown","slug":"markdown","link":"/tags/markdown/"},{"name":"db","slug":"db","link":"/tags/db/"},{"name":"aop","slug":"aop","link":"/tags/aop/"},{"name":"retry","slug":"retry","link":"/tags/retry/"}],"categories":[{"name":"工具","slug":"工具","link":"/categories/%E5%B7%A5%E5%85%B7/"},{"name":"spring","slug":"spring","link":"/categories/spring/"},{"name":"blog","slug":"blog","link":"/categories/blog/"},{"name":"git","slug":"git","link":"/categories/git/"},{"name":"定时任务","slug":"定时任务","link":"/categories/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"},{"name":"mq","slug":"mq","link":"/categories/mq/"}]}